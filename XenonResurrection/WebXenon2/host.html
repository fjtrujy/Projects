<canvas id="canvas" style="border:1px #808080 dashed; width:960px; height:600px;"></canvas><br>

<script>
function* loc_1480E() { yield* sub_1480B(0x1480e); }
function* sub_10761() { /* ret */ }
function* sub_16EEF() {
    r16[bx] <<= 1;
    switch (r16[bx])
    {
        case 0: yield* loc_135CE(); return;
        case 2: yield* sub_16F7F(); return;
        case 4: yield* sub_16F00(); return;
        case 6: yield* sub_16FE0(); return;
        case 8: yield* sub_1705B(); return;
    }
}


function* indirectCall(seg, ptr)
{
    switch(ptr)
    {
        case 0x002a: yield* sub_1F2BA(); break;
        case 0x4311: yield* sub_14311(); break;
        case 0x4759: yield* sub_14759(); break;
        case 0x37df: yield* sub_137DF(); break;
        case 0x72c4: yield* sub_172C4(); break;
        case 0x758f: yield* sub_1758F(); break;
        case 0x655b: yield* sub_1655B(); break; // enter shop
        case 0x0853: yield* sub_10853(); break;
        case 0x0761: yield* sub_10761(); break;
        case 0x7520: yield* sub_17520(); break;
        case 0x70f1: yield* sub_170F1(); break;
        case 0x6EEF: yield* sub_16EEF(); break;
        case 0x41E2: yield* sub_141E2(); break;
        case 0x480b: yield* sub_1480B(0); break;
        case 0x714A: yield* sub_1714A(); break;
        case 0x08B9: yield* sub_108B9(); break; // strom?
        case 0x0f2b: yield* sub_10F2B(); break;
        case 0x37ca: yield* sub_137CA(); break; // swingtail
        case 0x1e61: yield* sub_11E61(); break; // hit2
        case 0x28df: yield* sub_128DF(); break; // hit3
        case 0x2ab2: yield* sub_12AB2(); break; // speed powerup
        case 0x3aa7: yield* sub_13AA7(); break; // hit1
        case 0x2a6e: yield* sub_12A6E(); break; // power powerup
        case 0x6d22: yield* sub_16D22(); break; // tree - animation
        case 0x3a39: yield* sub_13A39(); break; // swingtail hit
        case 0x308C: yield* sub_13246(); // gabo cannon combo!
                     yield* loc_1308C(); break; // rearshot powerup
        case 0x39ee: yield* sub_139EE(); break; // draw fire
        case 0x091f: yield* sub_1091F(); break; // draw fire
        case 0x0897: yield* sub_10897(); break; // lv2 boss
        case 0x3998: yield* sub_13998(); break; // explosion anim
        case 0x41fb: yield* sub_141FB(); break; // explosion cleanup
        case 0x1f4d: yield* sub_11F4D(); break; // tree bulet move
        case 0x3835: yield* sub_13835(); break;            
        case 0x3B76: yield* sub_13B76(); break;// tree hit 
        case 0x6a0a: yield* sub_16A0A(); break;//
        case 0x25a8: yield* sub_125A8(); break;//
        case 0x6aad: yield* sub_16AAD(); break;
        case 0x3bdf: yield* sub_13BDF(); break;
        case 0x6696: yield* sub_16696(); break; // worm hit
        case 0x69D0: yield* sub_169D0(); break; // worm segment fly
        case 0x66a6: yield* sub_166A6(); break;
        case 0x6ac7: yield* sub_16AC7(); break;
        case 0x6bca: yield* sub_16BCA(); break;
        case 0x2ad0: yield* sub_12AD0(); break;
        case 0x6e2c: yield* sub_16E2C(); break;
        case 0x71dd: yield* sub_171DD(); break;
        case 0x2a48: yield* sub_12A48(); break;
        case 0x714d: yield* sub_1714D(); break;
        case 0x69C8: yield* sub_169C8(); break;
        case 0x3246: yield* sub_13246(); break; // powerup - cannon
        case 0x3a99: yield* sub_13A99(); break;
        case 0x7569: yield* sub_17569(); break;
        case 0x8ca7: yield* sub_18CA7(); break; // zero!
        case 0x7f32: yield* sub_17F32(); break;
        case 0x7f79: yield* sub_17F79(); break;
        case 0x8e01: yield* sub_18E01(); break;
        case 0x89AE: yield* sub_189AE(); break;
        case 0x88A9: yield* sub_188A9(); break;
        case 0x8C3E: yield* sub_18C3E(); break;
        case 0x7DDE: yield* sub_17DDE(); break;
        case 0x6284: break; // retn
        case 0x9f02: yield* sub_19F02(); break;
        case 0x9f4E: yield* sub_19F4E(); break;
        case 0x21e9: yield* sub_121E9(); break; // cannon
        case 0x246d: yield* sub_1246D(); break; // cannon
        case 0x28b8: yield* sub_128B8(); break; // cannon fire
        // level 2    
        case 0x4f96: yield* sub_14F96(); break; // horse
        case 0x2aa4: yield* sub_12AA4(); break; // autoshoot
        case 0x80ca: yield* sub_180CA(); break;
        case 0x866d: yield* sub_1866D(); break; // lv2 boss
        case 0x8114: yield* sub_18114(); break;
        case 0x8126: yield* sub_18126(); break;
        case 0x80f5: yield* sub_180F5(); break;
        case 0x87D5: yield* sub_187D5(); break;
        case 0x8783: yield* sub_18783(); break;
        
        default:
            throw "wrong indirect";
    }
}

function* nullsub_1() {}
</script>

<script src="xenon2.js"></script>
<script src="xenon2.resources.js"></script>
<script src="ega.js"></script>

<script>
var _datab = new ArrayBuffer(0x10000*20);
var memory = new Uint8Array(_datab, 0, 0x10000*20);
var memorys = new Int8Array(_datab, 0, 0x10000*20);

//var _video = new Uint8Array(0x12000);

var _stackb = new ArrayBuffer(0x100*2);
var _stack = new Uint16Array(_stackb, 0, 0x100);
var _stacks = new Int16Array(_stackb, 0, 0x100);

var r0 = new ArrayBuffer(16);
var r16 = new Uint16Array(r0, 0, 8);
var r16s = new Int16Array(r0, 0, 8);
var r8 = new Uint8Array(r0, 0, 16);
var r8s = new Int8Array(r0, 0, 16);

// index -> r16
var ax = 0, bx = 1, cx = 2, dx = 3, tx = 4, si = 5, di = 6;
// index -> r8
var al = 0, ah = 1, bl = 2, bh = 3, cl = 4, ch = 5, dl = 6, dh = 7, tl = 8, th = 9;
// other registers
var ds = 0, es = 0;
var bp = 0, sp = 0x100;

flags = {carry:0, direction:0, zero:0};
var _seg000 = 0x1000 - 0x1000;
var _seg001 = 0x1f29 - 0x1000;
var _seg002 = 0x24b9 - 0x1000;
var _seg003 = 0x2565 - 0x1000;
var _dseg   = 0x2853 - 0x1000;
var _seg005 = 0x3824 - 0x1000;
var _seg006 = 0x447b - 0x1000;
var _seg007 = 0x449b - 0x1000;
var _seg008 = 0x5489 - 0x1000;
var _seg009 = 0x63d0 - 0x1000;
var _seg010 = 0x7218 - 0x1000;

var dseg = _dseg;
var _ss = _seg006;

  var data = Module['xenon2.data'];
  for (var i=0; i<data.length; i++)
    memory[0x1000*0+i] = data[i];
  ds = _seg001;
  EGA.init();

//start();

var _freeMem = 0x2000;
var _currentFile;

function interrupt(i)
{
    if (i == 0x16 && r8[ah] == 0x00)
    {
        r8[ah] = 0x1c;
        return;
    }
    if (i == 0x10 && r8[ah] == 0x1a)
    {
        //https://dos4gw.org/INT_10H_1aH_Set_or_Query_Display_Combination_Code
        r8[al] = 0x1a;
        r8[bl] = 0x08; // vga color
        return;            
    }
    if (i == 0x10 && r8[ah] == 0x0f)
        return;
    if (i == 0x10 && r8[ah] == 0x01)
        return;
    if (i == 0x10 && r8[ah] == 0x06)
        return;
    if (i == 0x10 && r8[ah] == 0x02)
        return;
    if (i == 0x10 && r8[ah] == 0x09)
        return;
    if (i == 0x10 && r8[ah] == 0x00)
        return;
    if (i == 0x10 && EGA.Interrupt())
        return;

    if (i == 0x80)
    {
        sub_24B90();
        return;
    }

    if (i == 0x21 && r8[ah] == 0x25)
        return; // set int vect
    if (i == 0x21 && r8[ah] == 0x35)
        return; // get int vect

    if (i == 0x21 && r8[ah] == 0x3d)
    {   // open file
        var filename = "";
        var dot = false;
        for (var i=0; i<100; i++)
        {
            var c = String.fromCharCode(memory[ds*16+r16[dx]+i]);
            if (c==' ')
                continue;
            if (c=='\0')
                break;
            if (c=='\\')
                c='/';
            filename += c;
        }
        console.log("Open: " + filename);
        if (!Module[filename])
          throw "resource not found";
        _currentFile = {ofs:0, len:Module[filename].length, data:Module[filename]};
        flags.carry = 0;
        r16[ax] = 1;
        return; 
    }
    if (i == 0x21 && r8[ah] == 0x3f)
    {
        var bytes = Math.min(r16[cx], _currentFile.len); 
        var wptr = ds*16+r16[dx];
        var rptr = _currentFile.ofs;
        _currentFile.ofs += bytes;
        while(bytes--)
            memory[wptr++] = _currentFile.data[rptr++];
        flags.carry = 0;
        return;
    }

    if (i == 0x21 && r8[ah] == 0x3e)
    {   // close file
        _currentFile = null;
        return;
    }

    console.log("Interrupt " + i.toString(16) + " ah="  + r8[ah].toString(16));

    throw "uknown int";
    if (i == 0x21 && r8[ah] == 0x4a)
    {   // resize block
        flags.carry = false;
        return;
    }
    if (i == 0x21 && r8[ah] == 0x48)
    {   // malloc
        r16[ax] = _freeMem;
        _freeMem += r16[bx];
        flags.carry = false;
        return;
    }
    if (i == 0x21 && r8[ah] == 0x25)
        return; // set int vect
    if (i == 0x21 && r8[ah] == 0x35)
        return; // get int vect
    if (i == 0x21 && r8[ah] == 0x3d)
    {   // open file
        var filename = "";
        var dot = false;
        for (var i=0; i<100; i++)
        {
            var c = String.fromCharCode(memory[ds*16+r16[dx]+i]);
            if (c==' ')
                continue;
            if (c=='\0')
                break;
            filename += c;
        }
        console.log("Open: " + filename);
        if (!Module[filename])
          throw "resource not found";
        _currentFile = {ofs:0, len:Module[filename].length, data:Module[filename]};
        flags.carry = 0;
        r16[ax] = 1;
        return; 
    }
    if (i == 0x21 && r8[ah] == 0x3f)
    {
        var bytes = Math.min(r16[cx], _currentFile.len); 
        var wptr = ds*16+r16[dx];
        var rptr = _currentFile.ofs;
        _currentFile.ofs += bytes;
        while(bytes--)
            memory[wptr++] = _currentFile.data[rptr++];
        flags.carry = 0;
        return;
    }

    if (i == 0x21 && r8[ah] == 0x3e)
    {   // close file
        _currentFile = null;
        return;
    }

    if (i == 0x10 && r8[ah] == 0x0f)
        return;
    if (i == 0x10 && r8[ah] == 0x00)
        return;
    if (i == 0x10 && r8[ah] == 0x10 && r8[al] == 0)
    {
        //EGA.SetPaletteIndex(r8[bl], r8[bh]);
        return;
    }
    if (i == 0x10 && r16[ax] == 0x1012)
    {
      for (var i=0; i<r16[cx]; i++)
      {
        var r = memory[es*16+r16[dx]+i*3]*4;
        var g = memory[es*16+r16[dx]+i*3+1]*4;
        var b = memory[es*16+r16[dx]+i*3+2]*4;
        EGA.palette[i] = b | (g << 8) | (r << 16);
      }
    }
}

function out8(p, v)
{
    if (EGA.PortWrite8(p, v))
        return;
    console.log("out8: "+p.toString(16) + " <- " + v.toString(16));
}
function out16(p, v)
{
    if (EGA.PortWrite16(p, v))
        return;
    console.log("out16: "+p.toString(16) + " <- " + v.toString(16));
}

function lodsb_data_forward()
{
  assert(ds < 0xa000 && ds*16 + r16[si] < memory.length && r16[si] <= 0xffff);
  r8[al] = memory[ds*16 + r16[si]++];
}

function lodsw_data_forward()
{
  assert(ds < 0xa000 && ds*16 + r16[si] < memory.length && r16[si] <= 0xffff);
  r8[al] = memory[ds*16 + r16[si]++];
  r8[ah] = memory[ds*16 + r16[si]++];
}

function lodsb_video_forward()
{
  assert(ds >= 0xa000 && r16[si] <= 0xffff);
  r8[al] = EGA.read(ds*16 + r16[si]++);
}

function movsb_video_video_forward()
{
  assert(es >= 0xa000 && ds >= 0xa000 && r16[si] <= 0xffff && r16[di] <= 0xffff);
  EGA.write(es*16 + r16[di]++, EGA.read(ds*16 + r16[si]++));
}

function movsb_video_data_forward()
{
  assert(es >= 0xa000 && ds < 0xa000 && r16[si] <= 0xffff && r16[di] <= 0xffff);
  EGA.write(es*16 + r16[di]++, memory[ds*16 + r16[si]++]);
}

function movsb_auto_auto_auto()
{
  if (es < 0xa000 && ds < 0xa000)
    movsb_data_data_forward();
  else
  if (es >= 0xa000 && ds < 0xa000)
    movsb_video_data_forward();
  else
  if (es >= 0xa000 && ds >= 0xa000)
    movsb_video_video_forward(); 
  else
    assert(0);
}

function stosb_data_forward()
{
  assert(es < 0xa000  && es*16 + r16[di] < memory.length && r16[di] <= 0xffff);

  memory[es*16 + r16[di]++] = r8[al];
}

function stosb_video_forward()
{
  assert(es >= 0xa000);
  EGA.write(es*16 + r16[di]++, r8[al]);
}

function rep_stosb_data_forward()
{
  assert(es < 0xa000 && r16[cx] > 0 && es*16 + r16[di] < memory.length && r16[di] <= 0xffff);

  while (r16[cx]--)              
    memory[es*16 + r16[di]++] = r8[al];
  r16[cx] = 0;
}

function rep_stosb_video_forward()
{
  assert(es >= 0xa000 && r16[cx] > 0 && r16[di] <= 0xffff);

  while (r16[cx]--)
    EGA.write(es*16 + r16[di]++, r8[al]); 
  r16[cx] = 0;
}

function rep_movsb_data_data_forward()
{
  assert(es < 0xa000 && ds < 0xa000 && r16[cx] > 0 && r16[si] <= 0xffff && r16[di] <= 0xffff);
  assert(ds*16 + r16[si] < memory.length && es*16 + r16[di] < memory.length);

  while (r16[cx]--) 
    memory[es*16 + r16[di]++] = memory[ds*16 + r16[si]++];
  r16[cx] = 0;
}

function rep_movsb_data_data_backward()
{
  assert(es < 0xa000 && ds < 0xa000 && r16[cx] > 0 && r16[si] <= 0xffff && r16[di] <= 0xffff);
  assert(ds*16 + r16[si] < memory.length && es*16 + r16[di] < memory.length);

  while (r16[cx]--) 
    memory[es*16 + r16[di]--] = memory[ds*16 + r16[si]--];
  r16[cx] = 0;
}

function rep_movsb_video_data_forward()
{
  assert(es >= 0xa000 && ds < 0xa000 && r16[cx] > 0 && r16[si] <= 0xffff && r16[di] <= 0xffff);
  assert(ds*16 + r16[si] < memory.length && es*16 + r16[di] < memory.length);

  while (r16[cx]--) 
    EGA.write(es*16 + r16[di]++, memory[ds*16 + r16[si]++]);
  r16[cx] = 0;
}

function movsb_data_data_forward()
{
  assert(es < 0xa000 && ds < 0xa000);

  memory[es*16 + r16[di]++] = memory[ds*16 + r16[si]++];
}

function movsw_data_data_forward()
{
  assert(ds && es)
  assert(es < 0xa000 && ds < 0xa000 && r16[cx] > 0);

  memory[es*16 + r16[di]++] = memory[ds*16 + r16[si]++];
  memory[es*16 + r16[di]++] = memory[ds*16 + r16[si]++];
}

function rep_movsw_data_data_forward()
{
  assert(ds && es)

  assert(es < 0xa000 && ds < 0xa000 && r16[cx] > 0);
  assert(ds*16 + r16[si] < memory.length && es*16 + r16[di] < memory.length);

  while (r16[cx]--)
  { 
    memory[es*16 + r16[di]++] = memory[ds*16 + r16[si]++];
    memory[es*16 + r16[di]++] = memory[ds*16 + r16[si]++];
  }
  r16[cx] = 0;
}

function rep_movsw_data_data_backward()
{
  assert(es < 0xa000 && ds < 0xa000 && r16[cx] > 0 && r16[si] <= 0xffff && r16[di] <= 0xffff);
  assert(ds*16 + r16[si] < memory.length && es*16 + r16[di] < memory.length);

  while (r16[cx]--)
  { 
    memory[es*16 + r16[di]--] = memory[ds*16 + r16[si]--];
    memory[es*16 + r16[di]--] = memory[ds*16 + r16[si]--];
  }
  r16[cx] = 0;
}

function rep_movsb_video_video_forward()
{
  assert(es >= 0xa000 && ds >= 0xa000 && r16[cx] > 0 && r16[si] <= 0xffff && r16[di] <= 0xffff);

  while (r16[cx]--) 
    EGA.write(es*16 + r16[di]++, EGA.read(ds*16 + r16[si]++));
  r16[cx] = 0;
}


function rep_movsw_video_data_forward()
{
  assert(es >= 0xa000 && ds < 0xa000 && r16[cx] > 0 && r16[si] <= 0xffff && r16[di] <= 0xffff);
  assert(ds*16 + r16[si] < memory.length);
  while (r16[cx]--) 
  {
    EGA.write(es*16 + r16[di]++, memory[ds*16 + r16[si]++]);
    EGA.write(es*16 + r16[di]++, memory[ds*16 + r16[si]++]);
  }
  r16[cx] = 0;
}

function stosw_data_forward()
{
    assert(es*16 + r16[di] < memory.length && r16[di] <= 0xffff);

    assert(es < 0xa000);
    memory[es*16 + r16[di]++] = r8[al];
    memory[es*16 + r16[di]++] = r8[ah];
}


function rep_stosw_data_forward()
{
  while (r16[cx]--) 
    stosw_data_forward();
  r16[cx] = 0;
}


function push(i)
{
  _stack[sp>>1] = i;
  sp -= 2;
}
function pop()
{
  sp += 2;
  return _stack[sp>>1];
}
function lea(r, s, o)
{
  r16[r] = o;
}

function memory16set(i, v)
{
  assert(i < memory.length);

  memory[i] = v & 0xff;
  memory[i+1] = v >> 8;
}
function memory16get(i)
{
  assert(i < memory.length);
  return memory[i] | (memory[i+1]<<8);
}

function signed8(v)
{
  r8[th] = v;
  return r8s[th];
}

function signed16(v)
{
  r16[tx] = v;
  return r16s[tx];
}

function _cwd()
{
    if (r16[ax] & 0x8000)
        r16[dx] = 0xffff;
    else
        r16[dx] = 0x0000;
}

function rcr8(r, c)
{
    assert(c == 1);
    var newCarry = !!(r8[r] & 0x1);
    r8[r] >>= 1;
    r8[r] |= flags.carry ? 0x80 : 0;
    flags.carry = newCarry;
}

function rcl16(r, c)
{
    assert(c == 1);
    var newCarry = !!(r16[r] & 0x8000);
    r16[r] <<= 1;
    r16[r] |= flags.carry;
    flags.carry = newCarry;
}

function _idiv(d)
{
    // DX:AX / d -> AX result, DX remainder
    var dw = (r16s[dx] << 16) | r16[ax];
    var result = dw / d;
    var remainder = dw % d;
    r16[ax] = result;
    r16[dx] = remainder;
}

function imul16(w)
{
    var v = r16s[ax] * signed16(w);
    r16[ax] = v & 0xffff;
    r16[dx] = v >> 16;
}

function sar8(r, c)
{
    r8s[r] >>= c;
}

function sar16(r, c)
{
    r16s[r] >>= c;
}

function rol16(r, c)
{
    assert(c>=1 && c<8);
    r16[r] = (r16[r] << c) | (r16[r] >> (16-c));
}

/*function rol8(r, c)
{
    assert(c>=1 && c<8);
    r8[r] = (r8[r] << c) | (r8[r] >> (8-c));
} */

function ror8(r, c)
{
    assert(c>=0 && c<8);
    r8[r] = (r8[r] >> c) | (r8[r] << (8-c));
}

function ror16(r, c)
{
    assert(c>=0 && c<16);
    r16[r] = (r16[r] >> c) | (r16[r] << (16-c));
}

function _cbw()
{
    r8[ah] = (r8[al] & 0x80) ? 0xff : 0x00;
}

function xchg8(a, b)
{
  var t = r8[a];
  r8[a] = r8[b];
  r8[b] = t;
}

function xchg16(a, b)
{          
  var t = r16[a];
  r16[a] = r16[b];
  r16[b] = t;
}

function xchgr16(r, addr)
{          
  var t = r16[r];
  r16[r] = memory16get(addr);
  memory16set(addr, t)
}

function div(r)
{
    assert(r != 0);
    var result = r16[ax] / r;
    var remain = r16[ax] % r;
    r16[ax] = result;
    r16[dx] = remain;
}

function _mul(v16)
{
//  r16[ax] = v16 * r8[al];
    var v = v16 * r16[ax];
    r16[ax] = v & 0xffff;
    r16[dx] = v >> 16;
}

function les(r, seg, ofs)
{
    r16[r] = memory16get(seg*16 + ofs);
    es = memory16get(seg*16 + ofs + 2);
}

function memory16gets(i)
{
    r16[tx] = memory[i] | (memory[i+1]<<8);
    return r16s[tx];
}

function memoryBiosGet16(seg, ofs)
{
    if (seg == 0x0040 && ofs == 0x0063)
        return 0x3d4;
    throw "not supported";
}

function memoryBiosSet16(seg, ofs, data)
{
    //word 0040:004E  Offset to the current display page
    if (ofs == 0x4E)
        return;
    throw "not supported";
}

function memoryVideoGet(seg, ofs)
{
    return EGA.read(seg*16+ofs);
}

function memoryVideoSet(seg, ofs, v)
{
    return EGA.write(seg*16+ofs, v);
}

function memoryVideoAnd(seg, ofs, v)
{
    EGA.write(seg*16+ofs, EGA.read(seg*16+ofs) & v);
}

function memoryVideoOr(seg, ofs, v)
{
    EGA.write(seg*16+ofs, EGA.read(seg*16+ofs) | v);
}

function pushf()
{
  push(flags.carry*1 + flags.zero*2);
}

function popf()
{
  var m = pop();
  flags.carry = m & 1;
  flags.zero = !!(m & 2);
}

function _xlat()
{
    r8[al] = memory[ds*16+ r16[bx]+r8[al]];
}

function _repne_scasb()
{
    assert(flags.direction == 0);
    flags.zero = 0;
    while ( r16[cx]-- && flags.zero == 0 )
    {
        flags.zero = (r8[al] - memory[es*16+ r16[di]]) == 0;
        r16[di]++;
    }
}

var _retrace = 0;
function in8(port)
{
/*
    //cout << "in(" << std::hex << (int)port << ")" << endl;
    if (port == 0x40)
    {
        val = 0;
        return;
    }
    if (port == 0x61) // speaker
    {
        val = 0;
        return;
    }
    if (port == 0x201) // joystick
    {
        val = 0xff;
        return;
    }
*/

  if (port == 0x61)
    return 0;
  if (port == 0x201)
    return 0;

    if (port == 0x3da)
    {
        return (_retrace++ & 1) ? 8 : 0;;
    }
    console.log("port in " + port.toString(16) + " not supported")
    throw "error";
}

var can = document.getElementById("canvas");
var ctx = can.getContext('2d');
can.width = 320;
can.height = 200;
var data = ctx.createImageData(can.width, can.height);

function display()
{
  var p = 0;
  var pixels = data.data;
  for (var y=0; y<200; y++)
    for (var x=0; x<320; x++)
    {

      var c = EGA.getPixel(x, y);
/*
          var _video = 0x2000*16;
          var mask = 0x80 >> (x % 8);
      
          var off = 0x800;
          var shift = y  + Math.floor(x / 8)*180;
          var b = 0;
          if ( memory[_video + shift + off*0] & mask ) b |= 1;
          if ( memory[_video +shift + off*1] & mask ) b |= 2;
          if ( memory[_video +shift + off*2] & mask ) b |= 4;
          if ( memory[_video +shift + off*3] & mask ) b |= 8;

          //mSdl.SetPixel(x+320, y, mVideo.palette[b]);
          var c = EGA.palette[b];
*/ 

      pixels[p++] = c>>16;
      pixels[p++] = (c>>8)&0xff;
      pixels[p++] = c & 0xff;
      pixels[p++] = 255;
    }
  ctx.putImageData(data, 0, 0);
}
var _iter = 0;
function* _sync(k)
{
  yield 0;
}

var sequence = start();
//sequence.next();
//function run()
{
  setInterval( () =>
  {
    sequence.next();
    display();
  }, 50);
}

///{
 // display();
//  if (_iter++ > 1)
//    throw new Error("Something went badly wrong!");
//}
function assert(x)
{
  if (!x) 
    throw new Error("assertion failed");
}

var _k = 0;
    document.onkeydown = function(evt) {
        evt = evt || window.event;
        switch (evt.keyCode)
        {
          case 38: _k |= 1; break;
          case 40: _k |= 2; break;
          case 37: _k |= 4; break;
          case 39: _k |= 8; break;
          case 32: _k |= 0x80;
           if (!(memory[_dseg*16+0x8f59] & 0x80))
                memory[_dseg*16+0x8F5B] = 0xff;
        }
        memory[_dseg*16+0x8f59] = _k;
    }
    document.onkeyup = function(evt) {
        evt = evt || window.event;
        switch (evt.keyCode)
        {
          case 38: _k &= ~1; break;
          case 40: _k &= ~2; break;
          case 37: _k &= ~4; break;
          case 39: _k &= ~8; break;
          case 32: _k &= ~0x80; break;
        }
        memory[_dseg*16+0x8f59] = _k;
    }

</script>
